1) Первая лабораторная:
Была написана программа выполняющая перемножение массива из 4х чисел размером 32 бита при помощи SSE инструкций. Так же была написана программа выполняющая эти действия последовательно. В результате сравнения производительности было выявлено, что программа использующая SSE инструкции выполняется в разы быстрее той (примерно в 7 раз), что делает перемножение последовательно. В сгенерированном коде ассемблера можно видеть что, операции, которые прописаны с помощью SSE были вставлены в код ассемблера.

2) Вторая лабораторная:
Была написана программа, которая используется pthreads, создавая многопоточное вычисление сложной задачи. Так же была написана программа, выполняющая вычисление сложной задачи последовательно. При сравнении производительности выяснилось что программа, использующая Pthreads, выполняется быстрее (примерно в 10 раз), чем та, что делает это последовательно.

3) Третья лабораторная:
При помощи OpenMP, была написана программа, которая создаёт n потоков и каждый из потоков выполняет длительную операцию. Сравнивая с последовательным выполнением и с программой, использующей pthreads, заметно что программа, использующая OpenMP является быстрейшей из всех вышеперечисленной, сильно быстрее последовательных операций и немногим быстрее, чем программа использующая pthreads.

4) Четвёртая лабораторная:
Была написана программа, которая в каждом потоке считывает и записывает данные в HashMap, HashTable, synchonized HashMap, ConcurrenctHashMap. Функция чтения, записи была написана так, что бы она вызывала ошибку при использовании непотокобезопасной коллекции. Производительность коллекций от самой быстрой, до самой медленной выглядит следующим образом - ConcurrentHashMap, SyncMap, HashMap и HashTable.
